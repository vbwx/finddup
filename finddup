#!/usr/bin/env perl

use strict;
use Digest::CRC;
use File::Find;
use Getopt::Std;
use File::Spec::Functions;
use Sort::Key::Natural 'natsort';
use Text::Glob 'match_glob';

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our $VERSION = '1.2';
our ($opt_l, $opt_o, $opt_O, $opt_r, $opt_p, $opt_f, $opt_b, $opt_t, $opt_a, $opt_n, $opt_i);
our ($opt_q, $opt_H, $opt_L, $opt_P, $opt_I, $opt_X, $opt_0);

my @dir = ();
my %files = ();
my %names = ();
my $n = "\n";
my $digest;
my $found = 0;

getopts('loOrqpfbtaniHLPI:X:0');
$opt_t = $opt_b = 1 unless $opt_t || $opt_b;
$opt_p = $opt_f = 0 if $opt_p && $opt_f;
$opt_H = $opt_L = 0 if $opt_P;
$opt_H ||= $opt_L;
if ($opt_i) {
	$opt_I = lc $opt_I;
	$opt_X = lc $opt_X;
}

for (@ARGV) {
	next if -l && $opt_r && !$opt_H;
	$_ = canonpath($_);
	if (-f) {
		my $t;
		$t = -T _ unless $opt_t && $opt_b;
		if (($t && $opt_t) || (!$t && $opt_b)) {
			$digest = digest($_);
			if ($digest) {
				$files{$digest} = $_;
				$names{basename($_)} = 1 if $opt_n;
			}
		}
	}
	elsif (-d _) {
		push(@dir, $_);
	}
	else {
		print STDERR "finddup: $_: No such file or directory\n";
		exit 1;
	}
}
if ($opt_0) {
	$n = "\0";
	$opt_o = 1 unless $opt_l;
}
my $all = !%files;
$opt_o ||= (keys %files == 1) unless $opt_l;
@dir = ('.') unless @dir;

find({preprocess => sub {natsort(@_)}, wanted => sub {
	my $f = ($opt_i ? lc $_ : $_).(-d ? '/' : '');
	if (!(-f) || (!$opt_a && /^[.~]|\r$|^Thumbs\.db$/) || (!$opt_L && -l) ||
		($opt_X && match_glob($opt_X, $f)) || ($opt_I && !match_glob($opt_I, $f))) {
		$File::Find::prune = 1 unless $opt_r || $_ eq '.';
		return;
	}
	return if $opt_n && !$names{$f};
	my $t = -T _ unless $opt_t && $opt_b;
	return if ($t && !$opt_t) || (!$t && !$opt_b);
	my $name = $File::Find::name =~ s/^\.\///r;
	my $digest = digest($_) or return;
	if ($files{$digest} && $files{$digest} ne $name && (!$opt_n || $f eq basename($files{$digest}))) {
		if ($opt_l) {
			print "$name$n$files{$digest}$n";
		}
		elsif ($opt_O) {
			print "$files{$digest}$n";
		}
		elsif ($opt_o) {
			print "$name$n";
		}
		else {
			print "$name ".($opt_f ? "~~" : "==")." $files{$digest}\n";
		}
		$found++;
	}
	elsif ($all) {
		$files{$digest} = $name;
		$names{basename($_)} = 1 if $opt_n;
	}
}, follow => $opt_L}, @dir);

print STDERR (($found ? "\n$found" : 'No'), ($opt_f && $found ? ' probable' : ''),
	' duplicate', ($found == 1 ? '' : 's'), "\n") unless $opt_q;
exit !$found;


sub basename {
	my $f = substr($_[0], rindex($_[0], '/') + 1);
	return ($opt_i ? lc $f : $f);
}

sub digest {
	my ($file, $data, $digest, $hex, $s);
	my $path = shift;
	if (open($file, '<', $path)) {
		my $size = -s $file;
		if ($opt_f) {
			$s = int($size/5);
			for (1 .. 6) {
				if ($_ == 6) {
					seek($file, -4, 2);
				}
				elsif ($_ > 1) {
					seek($file, $s, 1);
				}
				$hex .= (read($file, $data, 4) ? unpack('H*', $data) : 'x');
			}
		}
		else {
			$s = int($size/($opt_p ? 4 : 2));
			my $d = Digest::CRC->new(type => ($opt_p ? 'crc64' : 'crc32'));
			$d->addfile($file);
			$digest = $d->hexdigest;
			seek($file, $s, 0);
			$hex = (read($file, $data, 2) ? unpack('H*', $data) : 'x');
			if ($opt_p) {
				for (1, 2) {
					seek($file, $s, 1);
					$hex .= (read($file, $data, 2) ? unpack('H*', $data) : 'x');
				}
			}
		}
		close $file;
		return sprintf('%x', $size).$hex.$digest;
	}
	else {
		print STDERR "finddup: $path: Permission denied\n" unless $opt_q;
		return '';
	}
}

sub HELP_MESSAGE {
	print STDERR <<EOL;
Usage: finddup [-ainqr0] [-p | -f] [-b | -t] [-o | -O | -l]
               [-L | -H | -P] [-I GLOB] [-X GLOB] [FILE ...] [DIR ...]

Options:
    -a   Compare all files, including hidden files, such as `Thumbs.db'
         and `Icon?'.

    -i   Ignore case when using `-n', `-I', or `-X'.

    -n   Files are only duplicates when their names match as well.

    -q   Do not print number of found duplicates.

    -r   Look for files in subdirectories as well.

    -0   Separate paths with NUL characters; useful for `xargs -0'.
         Implies `-o' unless `-O' or `-l' is specified.

    -p   Compare files with higher precision by using CRC64 instead of CRC32.

    -f   Only compare file sizes and small samples of file contents instead
         of checksums. This speeds up the process considerably.

    -b   Only compare binary files.

    -t   Only compare text files.

    -o   Only print paths of files that are duplicates of other files.

    -O   Only print paths of files that have at least one duplicate.
         This switch might cause paths to be printed multiple times.

    -l   Print paths of file and its duplicate on separate lines.

    -L   Follow all symbolic links.

    -P   Follow no symbolic links. This is the default.

    -H   Follow symbolic links on the command line.

    -I GLOB
         Only compare files matching the pattern GLOB.
         Directory names end with `/'.

    -X GLOB
         Do not compare files matching the pattern GLOB.
         Directory names end with `/'.
EOL
}

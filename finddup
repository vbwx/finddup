#!/usr/bin/env perl

use strict;
use 5.016;
use Getopt::Std;
use File::Find;
use File::Compare;
use File::Spec::Functions;
use Sort::Key::Natural qw(natsort natkeysort);
use Text::Glob 'match_glob';
use Fcntl ':seek';

use constant {
	NO => 0,
	YES => 1,
	PATH => 0,
	SIZE => 1,
	COMPARE => 1,
	INDEX => 1,
	TIME => 2,
	EX_USAGE => 2
};

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our $VERSION = '1.6';
our ($opt_l, $opt_o, $opt_O, $opt_R, $opt_r, $opt_p, $opt_t, $opt_B, $opt_T, $opt_m, $opt_M, $opt_n);
our ($opt_i, $opt_a, $opt_s, $opt_S, $opt_e, $opt_q, $opt_H, $opt_L, $opt_P, $opt_I, $opt_X, $opt_0);

my @dir = ();
my %files = ();
my $found = 0;

getopts('loOsSmMn0RrqptBTaeiHLPI:X:') or die '', EX_USAGE;
if ($opt_l + $opt_o + $opt_O + $opt_s + $opt_S + $opt_m + $opt_M + $opt_n > 1) {
	die "Mutually exclusive options: ".($opt_l && 'l ').($opt_m && 'm ').($opt_M && 'M').
		($opt_o && 'o ').($opt_O && 'O ').($opt_s && 's ').($opt_S && 'S '), EX_USAGE;
}
if ($opt_p && ($opt_t || $opt_s || $opt_S)) {
	die "Mutually exclusive options: p ".($opt_t && 't ').($opt_s && 's').($opt_S && 'S'), EX_USAGE;
}
if ($opt_B && $opt_T) {
	die "Mutually exclusive options: B T", EX_USAGE;
}
$opt_T = $opt_B = YES unless $opt_T || $opt_B;
$opt_s ||= $opt_S;
$opt_m ||= $opt_M;
$opt_r ||= $opt_R;
$opt_t = YES if $opt_s;
$Text::Glob::strict_leading_dot = NO if $opt_a;
if ($opt_P) {
	$opt_H = $opt_L = NO;
}
else {
	$opt_H ||= $opt_L;
}
if ($opt_i) {
	$opt_I = fc $opt_I;
	$opt_X = fc $opt_X;
}
if ($opt_0) {
	$\ = "\0";
	$opt_o = YES unless $opt_O || $opt_l || $opt_s || $opt_m || $opt_n;
}
else {
	$\ = "\n";
}

for (@ARGV) {
	next if -l && !$opt_H;
	$_ = canonpath($_);
	if (-f) {
		my $t = -T _ unless $opt_T && $opt_B;
		next unless (!$t && $opt_B) || ($t && $opt_T);
		my $s = -s _;
		next if $opt_e && !$s;
		if ($opt_t) {
			my $digest = trim_digest($_, $s) or next;
			push(@{$files{$digest}}, ($opt_m ? [$_, $s, -M _] : [$_, $s])); # [PATH, SIZE, TIME]
		}
		else {
			push(@{$files{$s}}, ($opt_m ? [$_, YES, -M _] : [$_, YES])); # [PATH, COMPARE, TIME]
		}
	}
	elsif (-d _) {
		push(@dir, $_);
	}
	else {
		die "$_: No such file or directory";
	}
}
my $all = !%files;
@dir = ('.') unless @dir || %files;

find({
	follow => $opt_L,
	preprocess => sub {natsort(@_)},
	wanted => sub {
		my $f = ($opt_i ? fc $_ : $_);
		if (!-f || (!$opt_a && /^[.~]|\r$|^Thumbs\.db$/) || (!$opt_L && -l) ||
			($opt_X && match_glob($opt_X, $f)) || ($opt_I && !match_glob($opt_I, $f))) {
			$File::Find::prune = YES unless $opt_r || $_ eq '.';
			return;
		}
		my $t = -T _ unless $opt_T && $opt_B;
		return unless (!$t && $opt_B) || ($t && $opt_T);
		my $s = -s _;
		return if $opt_e && !$s;
		my $name = $File::Find::name =~ s/^\.\///r;
		if ($opt_t) {
			my $digest = trim_digest($_, $s) or return;
			push(@{$files{$digest}}, ($opt_m ? [$name, $s, -M _] : [$name, $s])) if $all || $files{$digest};
			# [PATH, SIZE, TIME]
		}
		else {
			push(@{$files{$s}}, ($opt_m ? [$name, $all, -M _] : [$name, $all])) if $all || $files{$s};
			# [PATH, COMPARE, TIME]
		}
	}
}, @dir);

if ($opt_p) {
	for my $s (natkeysort {$files{$_}[0][PATH]} keys %files) {
		my @f = do {my %x; grep {!$x{@{$_}[PATH]}++} @{$files{$s}}};
		if (@f > 1) {
			sort_matches(\@f);
			for my $i (0 .. $#f-1) {
				if ($f[$i][COMPARE]) {
					for ($i+1 .. $#f) {
						if ($f[$_] && compare($f[$_][PATH], $f[$i][PATH]) == 0) {
							if ($opt_n) {
								delete @{$files{$s}}[$_, $i];
							}
							else {
								print_dup($f[$_][PATH], $f[$i][PATH]);
								$found++;
							}
							delete $f[$_];
						}
					}
				}
				elsif ($f[$i]) {
					last;
				}
			}
		}
	}
}
elsif ($opt_t) {
	for (natkeysort {$files{$_}[0][PATH]} keys %files) {
		my @f = do {my %x; grep {!$x{@{$_}[PATH]}++} @{$files{$_}}};
		if (@f > 1) {
			if ($opt_n) {
				delete $files{$_};
			}
			else {
				sort_matches(\@f);
				print_dup($f[$_][PATH], $f[0][PATH]) for 1 .. $#f;
				$found += @f - 1;
			}
		}
	}
}
else {
	for my $s (natkeysort {$files{$_}[0][PATH]} keys %files) {
		my @f = do {my %x; grep {!$x{@{$_}[PATH]}++} @{$files{$s}}};
		if (@f > 1) {
			sort_matches(\@f);
			my %m = ();
			for (0 .. $#f) {
				my $digest = digest($f[$_][PATH], $s) or next;
				if ($m{$digest}) {
					if ($opt_n) {
						delete @{$files{$s}}[$_, $m{$digest}[INDEX]];
					}
					else {
						print_dup($f[$_][PATH], $m{$digest}[PATH]);
						$found++;
					}
				}
				elsif ($f[$_][COMPARE]) {
					$m{$digest} = [$f[$_][PATH], $_]; # [PATH, INDEX]
				}
			}
		}
	}
}
if ($opt_n) {
	my @f;
	push(@f, do {my %x; map {@{$_}[PATH]} grep {$_ && !$x{@{$_}[PATH]}++} @{$files{$_}}}) for keys %files;
	print $_ for natsort(@f);
	$found = scalar @f;
}

print_info(($found ? "\n$found" : 'No'), ($found && !$opt_n ? ($opt_p ? ' exact' : ' possible') : ''),
	($opt_n ? ' unique file' : ' duplicate'), ($found == 1 ? '' : 's'));
exit !$found;


sub print_dup {
	my ($dup, $orig) = @_;
	if ($opt_o || $opt_s || $opt_m) {
		print $dup;
	}
	elsif ($opt_O) {
		print $orig;
	}
	elsif ($opt_l) {
		print $dup;
		print $orig;
	}
	else {
		print $dup.' '.($opt_p ? '==' : '~~').' '.$orig;
	}
	return;
}

sub print_info {
	say STDERR @_ unless $opt_q;
	return;
}

sub sort_matches {
	if ($opt_M) {
		@{$_[0]} = sort {@{$b}[TIME] <=> @{$a}[TIME]} @{$_[0]};
	}
	elsif ($opt_m) {
		@{$_[0]} = sort {@{$a}[TIME] <=> @{$b}[TIME]} @{$_[0]};
	}
	elsif ($opt_S) {
		@{$_[0]} = sort {@{$a}[SIZE] <=> @{$b}[SIZE]} @{$_[0]};
	}
	elsif ($opt_s) {
		@{$_[0]} = sort {@{$b}[SIZE] <=> @{$a}[SIZE]} @{$_[0]};
	}
}

sub digest {
	my ($file, $data, $hex, $s);
	my ($path, $size) = @_;
	return 'x' unless $size;
	if (open($file, '<', $path)) {
		$s = int(($size - 30)/5); # 6 * 5B
		if ($s >= 0) {
			for (0 .. 5) {
				seek($file, $s, SEEK_CUR) if $_;
				read($file, $data, 5) or last;
				$hex .= unpack('H*', $data);
			}
		}
		elsif (read($file, $data, $size)) {
			$hex = unpack('H*', $data);
		}
		close $file;
		return $hex;
	}
	else {
		warn "$path: Permission denied";
		return '';
	}
}

sub trim_digest {
	my ($file, $data, $hex, $s, $c);
	my ($path, $size) = @_;
	return 'x' unless $size;
	if (open($file, '<', $path)) {
		$s = 0;
		$hex = unpack('H*', $c) if read($file, $c, 1);
		$s++ while read($file, $data, 1) && $c eq $data;
		$size -= $s;
		if ($size > 1) {
			seek($file, -1, SEEK_END);
			$hex .= unpack('H*', $c) if read($file, $c, 1);
			$size-- while seek($file, -2, SEEK_CUR) && read($file, $data, 1) && $c eq $data;
			if ($size > 2) {
				seek($file, $s + 1, SEEK_SET);
				$s = int(($size - 32)/5); # 2B + 6 * 5B
				if ($s >= 0) {
					for (0 .. 5) {
						seek($file, $s, SEEK_CUR) if $_;
						read($file, $data, 5) or last;
						$hex .= unpack('H*', $data);
					}
				}
				elsif (read($file, $data, $size - 2)) {
					$hex .= unpack('H*', $data);
				}
			}
		}
		close $file;
		return sprintf('%d:%s', $size, $hex);
	}
	else {
		warn "$path: Permission denied";
		return '';
	}
}

sub HELP_MESSAGE {
	print <<EOL;
Usage: finddup [-aeiqr0] [-p | -t] [-l | -o | -O | -s | -S | -m | -M | -n]
               [-B | -T] [-H | -L | -P] [-I GLOB] [-X GLOB] [FILE ...] [DIR ...]

Options:
  -a   Compare all files, including hidden files, such as `Thumbs.db'
       and `Icon?'.

  -e   Ignore empty files.

  -q   Do not print the number of found duplicates.

  -r   Look for duplicates in subdirectories as well.

  -0   Separate paths with NUL characters; useful for `xargs -0'.
       Implies `-o' unless `-O', `-s', `-S', `-m', `-M', or `-l'
       is specified.

  -p   Compare the entire contents of files. This is slower but only
       finds files that are perfect duplicates.

  -t   Trim repeating characters at the beginning and end of file
       contents before comparing them.

  -B   Only compare binary files.

  -T   Only compare text files.

  -l   Print paths of each file and its duplicate on separate lines.

  -o   Only print paths of files that are duplicates of other files.
       This is equivalent to the left path in the default output mode.

  -O   Only print paths of files that have at least one duplicate.
       This is equivalent to the right path in the default output mode.
       This switch might cause paths to be printed multiple times.

  -s   Only print paths of files that are either smaller or exact
       duplicates of other files.
       Implies `-t'.

  -S   Only print paths of files that are either larger or exact
       duplicates of other files.
       Implies `-t'.

  -m   Only print paths of files that are older than their duplicates.

  -M   Only print paths of files that are newer than their duplicates.

  -n   Only print paths of files that do not have duplicates.

  -H   Follow symbolic links on the command line.

  -L   Follow all symbolic links.

  -P   Do not follow symbolic links. This is the default.

  -I GLOB
       Only compare files matching the pattern GLOB.
       Call `perldoc Text::Glob' to learn about pattern syntax.

  -X GLOB
       Do not compare files matching the pattern GLOB.
       Call `perldoc Text::Glob' to learn about pattern syntax.

  -i   Ignore case when using `-I' or `-X'.
EOL
}

#!/usr/bin/env perl

use strict;
use 5.016;
use Getopt::Std;
use File::Find;
use File::Compare;
use File::Spec::Functions;
use Sort::Key::Natural qw(natsort natkeysort);
use Text::Glob 'match_glob';
use Fcntl ':seek';

use constant {
	NO => 0,
	YES => 1,
	PATH => 0,
	SIZE => 1,
	COMPARE => 1,
	TIME => 2
};

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our $VERSION = '1.5.1';
our ($opt_l, $opt_o, $opt_O, $opt_R, $opt_r, $opt_p, $opt_t, $opt_B, $opt_T, $opt_m, $opt_M);
our ($opt_i, $opt_a, $opt_s, $opt_S, $opt_e, $opt_q, $opt_H, $opt_L, $opt_P, $opt_I, $opt_X, $opt_0);

my @dir = ();
my %files = ();
my $n = "\n";
my $found = 0;

getopts('loOsSmM0RrqptBTaeiHLPI:X:');
if ($opt_l + $opt_o + $opt_O + $opt_s + $opt_S + $opt_m + $opt_M > 1) {
	print STDERR "Contradictory options: ".($opt_l && 'l ').($opt_m && 'm ').($opt_M && 'M').
		($opt_o && 'o ').($opt_O && 'O ').($opt_s && 's ').($opt_S && 'S ')."\n";
	exit 64;
}
if ($opt_p && ($opt_t || $opt_s || $opt_S)) {
	print STDERR "Contradictory options: p ".($opt_t && 't ').($opt_s && 's').($opt_S && 'S')."\n";
	exit 64;
}
if ($opt_B && $opt_T) {
	print STDERR "Contradictory options: B T\n";
	exit 64;
}
$opt_T = $opt_B = YES unless $opt_T || $opt_B;
$opt_s ||= $opt_S;
$opt_m ||= $opt_M;
$opt_r ||= $opt_R;
$opt_t = YES if $opt_s;
$Text::Glob::strict_leading_dot = NO if $opt_a;
if ($opt_P) {
	$opt_H = $opt_L = NO;
}
else {
	$opt_H ||= $opt_L;
}
if ($opt_i) {
	$opt_I = fc $opt_I;
	$opt_X = fc $opt_X;
}
if ($opt_0) {
	$n = "\0";
	$opt_o = YES unless $opt_O || $opt_l || $opt_s || $opt_m;
}

for (@ARGV) {
	next if -l && !$opt_H;
	$_ = canonpath($_);
	if (-f) {
		my $t = -T _ unless $opt_T && $opt_B;
		next unless (!$t && $opt_B) || ($t && $opt_T);
		my $s = -s _;
		next if $opt_e && !$s;
		if ($opt_t) {
			my $digest = trim_digest($_, $s) or next;
			push(@{$files{$digest}}, ($opt_m ? [$_, $s, -M _] : [$_, $s])); # [PATH, SIZE, TIME]
		}
		else {
			push(@{$files{$s}}, ($opt_m ? [$_, YES, -M _] : [$_, YES])); # [PATH, COMPARE, TIME]
		}
	}
	elsif (-d _) {
		push(@dir, $_);
	}
	else {
		print STDERR "finddup: $_: No such file or directory\n";
		exit 66;
	}
}
my $all = !%files;
@dir = ('.') unless @dir || %files;

find({
	follow => $opt_L,
	preprocess => sub {natsort(@_)},
	wanted => sub {
		my $f = ($opt_i ? fc $_ : $_);
		if (!-f || (!$opt_a && /^[.~]|\r$|^Thumbs\.db$/) || (!$opt_L && -l) ||
			($opt_X && match_glob($opt_X, $f)) || ($opt_I && !match_glob($opt_I, $f))) {
			$File::Find::prune = YES unless $opt_r || $_ eq '.';
			return;
		}
		my $t = -T _ unless $opt_T && $opt_B;
		return unless (!$t && $opt_B) || ($t && $opt_T);
		my $s = -s _;
		return if $opt_e && !$s;
		my $name = $File::Find::name =~ s/^\.\///r;
		if ($opt_t) {
			my $digest = trim_digest($_, $s) or return;
			push(@{$files{$digest}}, ($opt_m ? [$name, $s, -M _] : [$name, $s])) if $all || $files{$digest};
			# [PATH, SIZE, TIME]
		}
		else {
			push(@{$files{$s}}, ($opt_m ? [$name, $all, -M _] : [$name, $all])) if $all || $files{$s};
			# [PATH, COMPARE, TIME]
		}
	}
}, @dir);

if ($opt_p) {
	for (natkeysort {$files{$_}[0][PATH]} keys %files) {
		my @f = do {my %x; grep {!$x{@{$_}[PATH]}++} @{$files{$_}}};
		if (@f > 1) {
			sort_matches(\@f);
			for my $i (0 .. $#f-1) {
				if ($f[$i][COMPARE]) {
					for ($i+1 .. $#f) {
						if ($f[$_] && compare($f[$_][PATH], $f[$i][PATH]) == 0) {
							printdup($f[$_][PATH], $f[$i][PATH]);
							undef $f[$_];
							$found++;
						}
					}
				}
				elsif ($f[$i]) {
					last;
				}
			}
		}
	}
}
elsif ($opt_t) {
	for (natkeysort {$files{$_}[0][PATH]} keys %files) {
		my @f = do {my %x; grep {!$x{@{$_}[PATH]}++} @{$files{$_}}};
		if (@f > 1) {
			sort_matches(\@f);
			printdup($f[$_][PATH], $f[0][PATH]) for 1 .. $#f;
			$found += @f - 1;
		}
	}
}
else {
	for my $s (natkeysort {$files{$_}[0][PATH]} keys %files) {
		my @f = do {my %x; grep {!$x{@{$_}[PATH]}++} @{$files{$s}}};
		if (@f > 1) {
			sort_matches(\@f);
			my %m = ();
			for (@f) {
				my $digest = digest(@{$_}[PATH], $s) or next;
				if ($m{$digest}) {
					printdup(@{$_}[PATH], $m{$digest});
					$found++;
				}
				elsif (@{$_}[COMPARE]) {
					$m{$digest} = @{$_}[PATH];
				}
			}
		}
	}
}


print STDERR (($found ? "\n$found" : 'No'), ($found ? ($opt_p ? ' exact' : ' possible') : ''),
	' duplicate', ($found == 1 ? '' : 's'), "\n") unless $opt_q;
exit !$found;


sub printdup {
	if ($opt_o || $opt_s || $opt_m) {
		print "$_[0]$n";
	}
	elsif ($opt_O) {
		print "$_[1]$n";
	}
	elsif ($opt_l) {
		print "$_[0]$n$_[1]$n";
	}
	else {
		print "$_[0] ".($opt_p ? "==" : "~~")." $_[1]\n";
	}
}

sub sort_matches {
	if ($opt_M) {
		@{$_[0]} = sort {@{$b}[TIME] <=> @{$a}[TIME]} @{$_[0]};
	}
	elsif ($opt_m) {
		@{$_[0]} = sort {@{$a}[TIME] <=> @{$b}[TIME]} @{$_[0]};
	}
	elsif ($opt_S) {
		@{$_[0]} = sort {@{$a}[SIZE] <=> @{$b}[SIZE]} @{$_[0]};
	}
	elsif ($opt_s) {
		@{$_[0]} = sort {@{$b}[SIZE] <=> @{$a}[SIZE]} @{$_[0]};
	}
}

sub digest {
	my ($file, $data, $hex, $s);
	my ($path, $size) = @_;
	return 'x' unless $size;
	if (open($file, '<', $path)) {
		$s = int(($size - 30)/5); # 6 * 5B
		if ($s >= 0) {
			for (0 .. 5) {
				seek($file, $s, SEEK_CUR) if $_;
				read($file, $data, 5) or last;
				$hex .= unpack('H*', $data);
			}
		}
		elsif (read($file, $data, $size)) {
			$hex = unpack('H*', $data);
		}
		close $file;
		return $hex;
	}
	else {
		print STDERR "finddup: $path: Permission denied\n";
		return '';
	}
}

sub trim_digest {
	my ($file, $data, $hex, $s, $c);
	my ($path, $size) = @_;
	return 'x' unless $size;
	if (open($file, '<', $path)) {
		$s = 0;
		$hex = unpack('H*', $c) if read($file, $c, 1);
		$s++ while read($file, $data, 1) && $c eq $data;
		$size -= $s;
		if ($size > 1) {
			seek($file, -1, SEEK_END);
			$hex .= unpack('H*', $c) if read($file, $c, 1);
			$size-- while seek($file, -2, SEEK_CUR) && read($file, $data, 1) && $c eq $data;
			if ($size > 2) {
				seek($file, $s + 1, SEEK_SET);
				$s = int(($size - 32)/5); # 2B + 6 * 5B
				if ($s >= 0) {
					for (0 .. 5) {
						seek($file, $s, SEEK_CUR) if $_;
						read($file, $data, 5) or last;
						$hex .= unpack('H*', $data);
					}
				}
				elsif (read($file, $data, $size - 2)) {
					$hex .= unpack('H*', $data);
				}
			}
		}
		close $file;
		return sprintf('%d:%s', $size, $hex);
	}
	else {
		print STDERR "finddup: $path: Permission denied\n";
		return '';
	}
}

sub HELP_MESSAGE {
	print <<EOL;
Usage: finddup [-aeiqr0] [-p | -t] [-B | -T] [-l | -o | -O | -s | -S | -m | -M]
               [-H | -L | -P] [-I GLOB] [-X GLOB] [FILE ...] [DIR ...]

Options:
  -a   Compare all files, including hidden files, such as `Thumbs.db'
       and `Icon?'.

  -e   Ignore empty files.

  -q   Do not print the number of found duplicates.

  -r   Look for files in subdirectories as well.

  -0   Separate paths with NUL characters; useful for `xargs -0'.
       Implies `-o' unless `-O', `-s', `-S', `-m', `-M', or `-l'
       is specified.

  -p   Compare the entire contents of files. This is slower but only
       finds files that are perfect duplicates.

  -t   Trim repeating characters at the beginning and end of file
       contents before comparing them.

  -B   Only compare binary files.

  -T   Only compare text files.

  -l   Print paths of each file and its duplicate on separate lines.

  -o   Only print paths of files that are duplicates of other files.
       This is equivalent to the left path in the default output mode.

  -O   Only print paths of files that have at least one duplicate.
       This is equivalent to the right path in the default output mode.
       This switch might cause paths to be printed multiple times.

  -s   Only print paths of files that are either smaller or exact
       duplicates of other files.
       Implies `-t'.

  -S   Only print paths of files that are either larger or exact
       duplicates of other files.
       Implies `-t'.

  -m   Only print paths of files that are older than their duplicates.

  -M   Only print paths of files that are newer than their duplicates.

  -H   Follow symbolic links on the command line.

  -L   Follow all symbolic links.

  -P   Do not follow symbolic links. This is the default.

  -I GLOB
       Only compare files matching the pattern GLOB.
       Call `perldoc Text::Glob' to learn about pattern syntax.

  -X GLOB
       Do not compare files matching the pattern GLOB.
       Call `perldoc Text::Glob' to learn about pattern syntax.

  -i   Ignore case when using `-I' or `-X'.
EOL
}

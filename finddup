#!/usr/bin/env perl

use strict;
use Digest::CRC;
use File::Find;
use Getopt::Std;
use File::Spec::Functions;
use Sort::Key::Natural 'natsort';
use Text::Glob 'match_glob';

$Getopt::Std::STANDARD_HELP_VERSION = 1;
our $VERSION = '1.2.1';
our ($opt_l, $opt_o, $opt_O, $opt_r, $opt_p, $opt_f, $opt_b, $opt_t, $opt_a, $opt_n, $opt_i);
our ($opt_q, $opt_H, $opt_L, $opt_P, $opt_I, $opt_X, $opt_0);

my @dir = ();
my %files = ();
my %names = ();
my $n = "\n";
my $found = 0;

getopts('loO0rqpfbtaniHLPI:X:');
$opt_t = $opt_b = 1 unless $opt_t || $opt_b;
$opt_p = $opt_f = 0 if $opt_p && $opt_f;
$opt_H = $opt_L = 0 if $opt_P;
$opt_H ||= $opt_L;
if ($opt_i) {
	$opt_I = lc $opt_I;
	$opt_X = lc $opt_X;
}
if ($opt_0) {
	$n = "\0";
	$opt_o = 1 unless $opt_l;
}

for (@ARGV) {
	next if -l && $opt_r && !$opt_H;
	$_ = canonpath($_);
	if (-f) {
		my $t = -T _ unless $opt_t && $opt_b;
		if ((!$t && $opt_b) || ($t && $opt_t)) {
			my $digest = digest($_) or next;
			if ($files{$digest} && $files{$digest} ne $_ &&
				(!$opt_n || basename($_) eq basename($files{$digest}))) {
				printdup($_, $files{$digest});
				$found++;
			}
			else {
				$files{$digest} = $_;
				$names{basename($_)} = 1 if $opt_n;
			}
		}
	}
	elsif (-d _) {
		push(@dir, $_);
	}
	else {
		print STDERR "finddup: $_: No such file or directory\n";
		exit 1;
	}
}
my $all = !%files;
@dir = ('.') unless @dir || %files;

find({preprocess => sub {natsort(@_)}, wanted => sub {
	my $f = ($opt_i ? lc $_ : $_).(-d ? '/' : '');
	if (!(-f) || (!$opt_a && /^[.~]|\r$|^Thumbs\.db$/) || (!$opt_L && -l) ||
		($opt_X && match_glob($opt_X, $f)) || ($opt_I && !match_glob($opt_I, $f))) {
		$File::Find::prune = 1 unless $opt_r || $_ eq '.';
		return;
	}
	return if $opt_n && !$all && !$names{$f};
	my $t = -T _ unless $opt_t && $opt_b;
	return if (!$t && !$opt_b) || ($t && !$opt_t);
	my $name = $File::Find::name =~ s/^\.\///r;
	my $digest = digest($_) or return;
	if ($files{$digest} && $files{$digest} ne $name && (!$opt_n || $f eq basename($files{$digest}))) {
		printdup($name, $files{$digest});
		$found++;
	}
	elsif ($all) {
		$files{$digest} = $name;
		$names{basename($_)} = 1 if $opt_n;
	}
}, follow => $opt_L}, @dir);

print STDERR (($found ? "\n$found" : 'No'), ($opt_f && $found ? ' probable' : ''),
	' duplicate', ($found == 1 ? '' : 's'), "\n") unless $opt_q;
exit !$found;


sub basename {
	my $f = substr($_[0], rindex($_[0], '/') + 1);
	return ($opt_i ? lc $f : $f);
}

sub printdup {
	if ($opt_l) {
		print "$_[0]$n$_[1]$n";
	}
	elsif ($opt_O) {
		print "$_[1]$n";
	}
	elsif ($opt_o) {
		print "$_[0]$n";
	}
	else {
		print "$_[0] ".($opt_f ? "~~" : "==")." $_[1]\n";
	}
}

sub digest {
	my ($file, $data, $digest, $hex, $s);
	my $path = shift;
	if (open($file, '<', $path)) {
		my $size = -s $file;
		if ($opt_f) {
			$s = int($size/5);
			for (1 .. 6) {
				if ($_ == 6) {
					seek($file, -4, 2);
				}
				elsif ($_ > 1) {
					seek($file, $s, 1);
				}
				$hex .= (read($file, $data, 4) ? unpack('H*', $data) : 'x');
			}
		}
		else {
			$s = int($size/($opt_p ? 4 : 2));
			my $d = Digest::CRC->new(type => ($opt_p ? 'crc64' : 'crc32'));
			$d->addfile($file);
			$digest = $d->hexdigest;
			seek($file, $s, 0);
			$hex = (read($file, $data, 2) ? unpack('H*', $data) : 'x');
			if ($opt_p) {
				for (1, 2) {
					seek($file, $s, 1);
					$hex .= (read($file, $data, 2) ? unpack('H*', $data) : 'x');
				}
			}
		}
		close $file;
		return sprintf('%x', $size).$hex.$digest;
	}
	else {
		print STDERR "finddup: $path: Permission denied\n" unless $opt_q;
		return '';
	}
}

sub HELP_MESSAGE {
	print <<EOL;
Usage: finddup [-ainqr0] [-p | -f] [-b | -t] [-o | -O | -l]
               [-H | -L | -P] [-I GLOB] [-X GLOB] [FILE ...] [DIR ...]

Options:
  -a   Compare all files, including hidden files, such as `Thumbs.db'
       and `Icon?'.

  -i   Ignore case when using `-n', `-I', or `-X'.

  -n   Files are only duplicates when their names match as well.

  -q   Do not print number of found duplicates.

  -r   Look for files in subdirectories as well.

  -0   Separate paths with NUL characters; useful for `xargs -0'.
       Implies `-o' unless `-O' or `-l' is specified.

  -p   Compare files with higher precision by using CRC64 instead of CRC32.

  -f   Only compare file sizes and small samples of file contents instead
       of checksums. This speeds up the process considerably.

  -b   Only compare binary files.

  -t   Only compare text files.

  -o   Only print paths of files that are duplicates of other files.
       This is equivalent to the left path in the default output mode.

  -O   Only print paths of files that have at least one duplicate.
       This is equivalent to the right path in the default output mode.
       This switch might cause paths to be printed multiple times.

  -l   Print paths of file and its duplicate on separate lines.

  -H   Follow symbolic links on the command line.

  -L   Follow all symbolic links.

  -P   Do not follow symbolic links. This is the default.

  -I GLOB
       Only compare files matching the pattern GLOB.
       For pattern matching purposes, directory names end with `/'.

  -X GLOB
       Do not compare files matching the pattern GLOB.
       For pattern matching purposes, directory names end with `/'.
EOL
}
